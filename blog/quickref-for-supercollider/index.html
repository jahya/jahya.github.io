<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=author content="Andrew McWilliams"><title>QuickRef for SuperCollider</title><link href=http://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css rel=stylesheet><link href="http://fonts.googleapis.com/css?family=Lato:300,400,300italic,400italic" rel=stylesheet type=text/css><link rel=stylesheet href=/stylesheets/style.83cf.css><!--[if lt IE 9]>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv-printshiv.min.js"></script>
    <![endif]--><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.4f09.png><link rel="shortcut icon" href=/images/favicon.6537.png></head><body id=blog class=content><header role=banner><h1><a href="/"><span class=shift>Andrew</span> M<span class=sub>c</span>Williams</a></h1><nav role=navigation><h2>Navigation</h2><a id=menu-button href=#><i class="fa fa-bars"></i> <i class="fa fa-times"></i></a><ul class=cta><li><a href="/about/">About</a></li><li><a href="/works/">Works</a></li><li><a href="/blog/">Blog</a></li></ul></nav></header><div class=flex-row><main class=left><article role=article itemscope itemtype=http://schema.org/BlogPosting><header><h1>QuickRef for SuperCollider</h1><div class=widgets>Posted on <time itemprop=dateCreated datetime=2012-06-04>Monday 4 June, 2012</time><ul class=social><li><a href="http://twitter.com/share?text=QuickRef%20for%20SuperCollider&amp;url=http://jahya.net/blog/quickref-for-supercollider&amp;via=hardwarehacklab"><i class="fa fa-twitter-square"></i></a></li><li><a href="http://www.facebook.com/sharer/sharer.php?title=QuickRef%20for%20SuperCollider&amp;u=http://jahya.net/blog/quickref-for-supercollider"><i class="fa fa-facebook-square"></i></a></li><li><a href="http://www.tumblr.com/share?v=3&amp;t=QuickRef%20for%20SuperCollider&amp;u=http://jahya.net/blog/quickref-for-supercollider"><i class="fa fa-tumblr-square"></i></a></li></ul></div></header><div class=post-content><p id=top>In <a href=//blog/getting-started-with-supercollider>a previous post</a> I mentioned <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Getting%20Started%20With%20SC.html>Scott Wilson's tutorial</a> as a really good starting point for learning SuperCollider (SC). Below I have summarised just about everything (including codeblocks) written in that tutorial, but this time all on one page!</p><p></p><p>This is so that once you have read the tutorial you have a Quick Reference to help you get started. You can navigate the material quickly using jumplinks:</p><script type=text/javascript>$(document).ready(function(){       var quickRefJumplinksHidden = false;    var quickRefJumplinksId = "quickRefJumplinks";    var showQuickRefJumplinksId = "showQuickRefJumplinks";    var showJumplinksText = "Show Jumplinks";    var hideJumplinksText = "Hide Jumplinks";       $("#" + quickRefJumplinksId)         .hide(0, function(){           quickRefJumplinksHidden = true;         })         .before("<p>&gt;&gt; <a href='#' id='" + showQuickRefJumplinksId + "'>" + showJumplinksText + "</a></p>");       $("#" + showQuickRefJumplinksId)         .click(function(){           if(quickRefJumplinksHidden){             $("#" + quickRefJumplinksId).slideDown(150,function(){               quickRefJumplinksHidden = false;               $("#" + showQuickRefJumplinksId).html(hideJumplinksText);             });           }else{             $("#" + quickRefJumplinksId).slideUp(150,function(){               quickRefJumplinksHidden = true;            $("#" + showQuickRefJumplinksId).html(showJumplinksText);             });           }           return false;         });     });</script><ul class=spacedlist id=quickRefJumplinks><li><a href=#First-Steps>Tutorial #1: First Steps</a></li><li><a href=#Start-Your-Engines>Tutorial #2: Start Your Engines</a></li><li><a href=#Functions-and-Other-Functionality>Tutorial #3: Functions and Other Functionality</a></li><li><a href=#Functions-and-Sound>Tutorial #4: Functions and Sound</a></li><li><a href=#Stereo>Tutorial #5: Stereo</a></li><li><a href=#Mixing>Tutorial #6: Mixing</a></li><li><a href=#Scoping-and-Plotting>Tutorial #7: Scoping and Plotting</a></li><li><a href=#Help>Tutorial #8: Help</a></li><li><a href=#SynthDefs>Tutorial #9: SynthDefs</a></li><li><a href=#Busses>Tutorial #10: Busses</a></li><li><a href=#Groups>Tutorial #11: Groups</a></li><li><a href=#Buffers>Tutorial #12: Buffers</a></li><li><a href=#Scheduling-Events>Tutorial #13: Scheduling Events</a></li><li><a href=#Scheduling-with-Routines-and-Tasks>Tutorial #14: Scheduling with Routines and Tasks</a></li><li><a href=#Scheduling-with-Patterns>Tutorial #15: Scheduling with Patterns</a></li></ul><p>...or just go ahead and scroll down the whole page.</p><p>There are also some common keyboard shortcuts and common SC methods right at the bottom: <a href=#Quick-references>Common methods and shortcuts</a></p><hr><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/First%20Steps.html class=linkheader name=First-Steps>Tutorial #1: First Steps</a></span></strong></p><p><strong>Literals and no-args</strong><br>You can treat <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Language/Literals.html>literals</a> as objects, and you can omit brackets for no-argument methods:</p><p class=code><code>&nbsp;&nbsp;"Hello World!".postln;<br>&nbsp;&nbsp;8.rand;</code></p><p><strong>Blocks (and variables)</strong><br>To execute several statements at once, wrap them in a block - double-click anywhere inside the brackets to select the whole block:</p><p class=code><code>&nbsp;&nbsp;(<br>&nbsp;&nbsp;"Call me, ".post;<br>&nbsp;&nbsp;"Ishmael.".postln;<br>&nbsp;&nbsp;)</code></p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Start%20Your%20Engines.html class=linkheader name=Start-Your-Engines>Tutorial #2: Start Your Engines</a></span></strong></p><p><strong>Boot a server</strong><br>Boot a localhost server via the GUI, or by code:</p><p class=code><code>&nbsp;&nbsp;s.quit;<br>&nbsp;&nbsp;s.boot;</code></p><p><strong>Interpreter variables</strong><br><code>s</code> is just an interpreter variable, which is pre-assigned the value from <code>Server.local</code>:</p><p class=code><code>&nbsp;&nbsp;Server.local.boot;</code></p><p>Interpreter variables (<code>a</code> - <code>z</code>) are pre-declared when you start up SC, and have global scope.</p><p><strong>Environment variables</strong><br>You can make your own variables that act like interpreter variables - you don't have to declare them and they have global scope (but for the same reason they are not efficient):</p><p class=code><code>&nbsp;&nbsp;~sources = //whatever</code></p><p>(They are introduced on the <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Groups.html>Groups page</a>)</p><p><strong>Local vs. internal</strong><br>The local server is the localhost, communicated with over the network, but residing on the same machine as the client. Using the local server is no different to using any networked sever.</p><p>The internal server runs as a process within the client app; basically a program within a program. The main advantage is that it allows the two applications to share memory, which allows for things like <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Scoping%20and%20Plotting.html>realtime scoping of audio</a>. The disadvantage is that the two are then interdependent, so if the client crashes, so does the server.</p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Functions%20and%20Other%20Functionality.html class=linkheader name=Functions-and-Other-Functionality>Tutorial #3: Functions and Other Functionality</a></span></strong></p><p><strong>Functions are objects</strong><br>Functions can be assigned and treated as objects:</p><p class=code><code>&nbsp;&nbsp;f = { "Function evaluated".postln; };<br>&nbsp;&nbsp;f.value;</code></p><p>(The method <code>.value</code> just says 'evaluate this method now')</p><p><strong>Arguments</strong><br>Functions can have arguments:</p><p class=code><code>&nbsp;&nbsp;f = { arg a, b; a - b; };<br>&nbsp;&nbsp;f.value(5, 3);</code></p><p><strong>Equivalent syntax</strong><br>Declare arguments within pipes:</p><p class=code><code>&nbsp;&nbsp;f = { |a, b| a - b; };</code></p><p><strong>Polymorphism</strong><br>SuperCollider supports polymorphism:</p><p class=code><code>&nbsp;&nbsp;f = { arg a; a.value + 3 };<br>&nbsp;&nbsp;f.value(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Send an int<br>&nbsp;&nbsp;f.value({ 3.0.rand; });&nbsp;&nbsp;&nbsp;//Send a function<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//...either way .value works just fine</code></p><p><strong>Named parameters</strong><br>You can use named parameters:</p><p class=code><code>&nbsp;&nbsp;f = { arg a, b; a / b; };<br>&nbsp;&nbsp;f.value(b: 2, a: 10);</code></p><p>(You can mix regular and named parameters, but regular must come first)</p><p><strong>Default arguments</strong><br>You can set defaults:</p><p class=code><code>&nbsp;&nbsp;f = { arg a, b = 2; a + b; };<br>&nbsp;&nbsp;f.value(2);&nbsp;&nbsp;&nbsp;&nbsp;// 2 + 2</code></p><p><strong>Method variables</strong><br>Internal method variables can be declared, but must be directly after <code>args</code>:</p><p class=code><code>&nbsp;&nbsp;f = {<br>&nbsp;&nbsp;&nbsp;&nbsp;arg a, b;<br>&nbsp;&nbsp;&nbsp;&nbsp;var myVar1, myVar2;<br>&nbsp;&nbsp;&nbsp;&nbsp;//rest of method<br>&nbsp;&nbsp;};</code></p><p><strong>Block variables</strong><br>Internal block variables must be declared at the start of the block:</p><p class=code><code>&nbsp;&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;var myFunc;<br>&nbsp;&nbsp;&nbsp;&nbsp;myFunc = { |input| input.postln; };<br>&nbsp;&nbsp;&nbsp;&nbsp;myFunc.value("foo");<br>&nbsp;&nbsp;&nbsp;&nbsp;myFunc.value("bar"); //etc<br>&nbsp;&nbsp;)</code></p><p><strong>Operator precedence</strong><br>There isn't any. Use brackets:</p><p class=code><code>&nbsp;&nbsp;1 + 2 * 3; //9<br>&nbsp;&nbsp;1 + (2 * 3); //7</code></p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Functions%20and%20Sound.html class=linkheader name=Functions-and-Sound>Tutorial #4: Functions and Sound</a></span></strong></p><p><strong>Instantiation methods</strong><br>Various static methods are designed to help you instantiate objects with certain properties:</p><p class=code><code>&nbsp;&nbsp;x = SomeObject.new(0.5) //equiv to x = SomeObject(0.5)<br>&nbsp;&nbsp;x = SinOsc.ar(440, 0, 0.2) //audio rate<br>&nbsp;&nbsp;x = SinOsc.kr(440, 0, 0.2) //control rate<br></code></p><p><strong>Unit generators</strong><br><code>SinOsc</code> is a type of <code>UGen</code>. The <code>ar</code> and <code>kr</code> methods accept common arguments:</p><p class=code><code>&nbsp;&nbsp;SinOsc.ar(freq, phase, mul)<br>&nbsp;&nbsp;//frequency is in Hertz<br>&nbsp;&nbsp;//phase is in radians (between 0 and 2*pi)<br>&nbsp;&nbsp;//mul is multiplier (aka amplitude)</code></p><p>(Read more on <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Functions%20and%20Sound.html>phase</a>)</p><p><strong>The 'add' argument</strong><br><code>UGen</code>s often also come with an optional 'add', as well as mul. These are useful to create kr signals, i.e. if you want to generate a smooth volume envelope:</p><p class=code><code>&nbsp;&nbsp;SinOsc.kr(0.5, 1.5pi, 0.5, 0.5);<br>&nbsp;&nbsp;//frequency = once every 2 seconds<br>&nbsp;&nbsp;//phase = start with volume at 0<br>&nbsp;&nbsp;//mul = reduce from (-1 to 1) to (-.5 to .5)<br>&nbsp;&nbsp;//add = shift from (-.5 to .5) to (0 to 1)</code></p><p><strong>Use the new kr UGen to control an ar UGen</strong><br>Use the <code>UGen</code> as a volume envelope on a <code>SinOsc</code>:</p><p class=code><code>&nbsp;&nbsp;{&nbsp;var ampOsc;<br>&nbsp;&nbsp;&nbsp;&nbsp;ampOsc = SinOsc.kr(0.5, 1.5pi, 0.5, 0.5);<br>&nbsp;&nbsp;&nbsp;&nbsp;SinOsc.ar(440, 0, ampOsc);<br>&nbsp;&nbsp;}.play;</code></p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Presented%20in%20Living%20Stereo.html class=linkheader name=Stereo>Tutorial #5: Stereo</a></span></strong></p><p><strong>Arrays = multi-channel</strong><br>Arrays are used to implement multi-channel audio. If your function returns an array of <code>UGen</code>s, the.play method will assign each to available channels:</p><p class=code><code>&nbsp;&nbsp;{ [SinOsc.ar(440, 0, 0.2), SinOsc.ar(442, 0, 0.2)] }.play;</code></p><p><strong>Multi-channel expansion</strong><br>If you pass an Array argument to a <code>UGen</code>, you get an Array of that <code>UGen</code>:</p><p class=code><code>&nbsp;&nbsp;{ [SinOsc.ar(440, 0, 0.2), SinOsc.ar(442, 0, 0.2)] }.play;<br>&nbsp;&nbsp;{ SinOsc.ar([440, 442], 0, 0.2) }.play; //equivalent to above</code></p><p><strong>Panning</strong><br>Use the <code>UGen</code> '<code>Pan2</code>' (demoed here with <code>PinkNoise</code>):</p><p class=code><code>&nbsp;&nbsp;{ Pan2.ar(PinkNoise.ar(0.2), -0.3) }.play; //fixed at -0.3<br>&nbsp;&nbsp;{ Pan2.ar(PinkNoise.ar(0.2), SinOsc.kr(0.5)) }.play; //moving</code></p><p>(More on <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Collections/Collections.html>SuperCollider Collections</a>)</p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Mix%20it%20Up.html class=linkheader name=Mixing>Tutorial #6: Mixing</a></span></strong></p><p><strong>Addition = mixing</strong><br>Use <code>+</code>, and a low number for mul, to mix <code>UGen</code> outputs together:</p><p class=code><code>&nbsp;&nbsp;{ PinkNoise.ar(0.2) + Saw.ar(660, 0.2) }.play;</code></p><p><strong>The 'Mix' class</strong><br>You can use Mix to mix an array of <code>UGen</code>s into a single channel:</p><p class=code><code>&nbsp;&nbsp;{ Mix.new(<br>&nbsp;&nbsp;&nbsp;&nbsp;[SinOsc.ar(440, 0, 0.2), Saw.ar(660, 0.2)]<br>&nbsp;&nbsp;).postln }.play;</code></p><p>...or to mix an array of arrays, i.e. an array of stereo channels, into a single stereo channel:</p><p class=code><code>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;var a, b;<br>&nbsp;&nbsp;&nbsp;&nbsp;a = [SinOsc.ar(440, 0, 0.2), Saw.ar(662, 0.2)];<br>&nbsp;&nbsp;&nbsp;&nbsp;b = [SinOsc.ar(442, 0, 0.2), Saw.ar(660, 0.2)];<br>&nbsp;&nbsp;&nbsp;&nbsp;Mix([a, b]).postln;<br>&nbsp;&nbsp;}.play;</code></p><p>Note that <code>Mix()</code> is equivalent to <code>Mix.new()</code>.</p><p><strong>Mixing on a loop</strong><br><code>Mix.fill</code> allows you to mix the same <code>UGen</code> multiple times with parameters:</p><p class=code><code>&nbsp;&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;var n = 8;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mix.fill(n,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ SinOsc.ar(500 + 500.0.rand, 0, 1 / n) }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;}.play;<br>&nbsp;&nbsp;)</code></p><p><strong>Mixing on a loop with an index parameter</strong><br>As above, but taking advantage of the <code>index</code> argument, which increments with each call:</p><p class=code><code>&nbsp;&nbsp;(<br>&nbsp;&nbsp;&nbsp;&nbsp;var n = 8;<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mix.fill(n,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg index;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var freq;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index.postln;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq = 440 + index;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freq.postln;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SinOsc.ar(freq , 0, 1 / n);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;}.play;<br>&nbsp;&nbsp;)</code></p><p>The <code>index</code> parameter is a special argument which is filled in for you by convention. See the <a href=#Special-arguments>list at the bottom of this post</a>.</p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Scoping%20and%20Plotting.html class=linkheader name=Scoping-and-Plotting>Tutorial #7: Scoping and Plotting</a></span></strong></p><p><strong>Plotting</strong><br>Make a graph of the signal produced by the output of the Function:</p><p class=code><code>&nbsp;&nbsp;{ PinkNoise.ar(0.2) + Saw.ar(660, 0.2) }.plot; //default 0.01<br>&nbsp;&nbsp;{ PinkNoise.ar(0.2) + Saw.ar(660, 0.2) }.plot(1); // 1 sec</code></p><p><strong>Scoping</strong><br>(Internal server only - make sure <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Scoping%20and%20Plotting.html>it is booted</a>)<br>Show an oscilloscope of the signal produced by the output of the Function:</p><p class=code><code>&nbsp;&nbsp;{ PinkNoise.ar(0.2) + Saw.ar(660, 0.2) }.scope;</code></p><p><strong>Scoping with zoom</strong><br>Just add the named parameter:</p><p class=code><code>&nbsp;&nbsp;{ PinkNoise.ar(0.2) + Saw.ar(660, 0.2) }.scope(zoom: 10);</code></p><p><strong>Scoping any time</strong><br>Scope the internal server anytime:</p><p class=code><code>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;[SinOsc.ar(440, 0, 0.2), SinOsc.ar(442, 0, 0.2)]<br>&nbsp;&nbsp;}.play(Server.internal);<br>&nbsp;&nbsp;Server.internal.scope; //or s.scope if internal is default</code></p><p><strong>Frequency scope</strong><br>A nice one (not mentioned in the tutorial) is the frequency analyzer:</p><p class=code><code>&nbsp;&nbsp;{ PinkNoise.ar(0.2) + Saw.ar(660, 0.2) }.freqscope;</code></p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Getting%20Help.html class=linkheader name=Help>Tutorial #8: Help</a></span></strong></p><p><strong>Syntax shortcuts</strong><br>Common syntax shortcuts are listed <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Language/Syntax-Shortcuts.html>here</a>. There are a range of shortcuts, particularly good for dealing with collections.</p><p><strong>Finding help</strong><br>The tutorial help page is <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Getting%20Help.html>here</a>, an extended help reference is here: <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/More-On-Getting-Help.html>More on Getting Help</a></p><p><strong>Snooping around SC</strong><br>SuperCollider has class browsers and other built-in approaches to snooping on source code - find out about them <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/More-On-Getting-Help.html>here</a>.</p><p><strong>Programmatically navigating the API</strong><br>Objects have methods for finding definitions (this is introduced on the <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Groups.html>Groups page</a>).</p><p class=code><code>&nbsp;&nbsp;Group.superclass;&nbsp;//this will return 'Node'<br>&nbsp;&nbsp;Group.superclass.openHelpFile;<br>&nbsp;&nbsp;Group.findRespondingMethodFor('set');&nbsp;//Node-set<br>&nbsp;&nbsp;Group.findRespondingMethodFor('postln');&nbsp;//Object-postln<br>&nbsp;&nbsp;Group.helpFileForMethod('postln');&nbsp;//opens Object help file<br></code></p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/SynthDefs%20and%20Synths.html class=linkheader name=SynthDefs>Tutorial #9: SynthDefs</a></span></strong></p><p><strong>Functions create SynthDefs</strong><br>If you <code>play</code> a function, behind the scenes it creates a <code>SynthDef</code>:</p><p class=code><code>&nbsp;&nbsp;//these two are equivalent<br>&nbsp;&nbsp;{ SinOsc.ar(440, 0, 0.2) }.play;<br>&nbsp;&nbsp;SynthDef.new("tutorial-SinOsc",<br>&nbsp;&nbsp;&nbsp;&nbsp;{ Out.ar(0, SinOsc.ar(440, 0, 0.2)) }<br>&nbsp;&nbsp;).play;</code></p><p>(The first argument to <code>SynthDef.new</code> identifies the <code>SynthDef</code>, the second is a function known as a 'UGen Graph Function', since it tells the synth how to connect various <code>UGen</code>s together to make a synth)</p><p><strong>Manipulate a SynthDef</strong><br><code>SynthDef.new</code> returns a <code>Synth</code>, which you can manipulate / free:</p><p class=code><code>&nbsp;&nbsp;x = { SinOsc.ar(660, 0, 0.2) }.play;<br>&nbsp;&nbsp;y = SynthDef.new("myDef",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Out.ar(0, SinOsc.ar(440, 0, 0.2)) }).play;<br>&nbsp;&nbsp;x.free; // free just x<br>&nbsp;&nbsp;y.free; // free just y</code></p><p><strong>Send and load</strong><br>Methods for sending a <code>SynthDef</code> to a server without causing playback. Allow you to create additional synths directly on the server without having to parse the code again:</p><p class=code><code>&nbsp;&nbsp;SynthDef.new("myDef",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Out.ar(0, PinkNoise.ar(0.3)) }).send(s);<br>&nbsp;&nbsp;x = Synth.new("myDef");<br>&nbsp;&nbsp;y = Synth.new("myDef");</code></p><p>(<code>send</code> just sends, <code>load</code> <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/SynthDefs%20and%20Synths.html>saves to disk</a> and the server reads from disk)</p><p><strong>Objects evaluate only on the client</strong><br>Compare the two examples - the first creates a new frequency each time, the second creates a new frequency once and that frequency is fixed with all new instantiations:</p><p class=code><code>&nbsp;&nbsp;f = { SinOsc.ar(440 + 200.rand, 0, 0.2) };<br>&nbsp;&nbsp;x = f.play;<br>&nbsp;&nbsp;y = f.play;<br>&nbsp;&nbsp;z = f.play;<br>&nbsp;&nbsp;x.free; y.free; z.free;<br><br>&nbsp;&nbsp;SynthDef("myDef",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ Out.ar(0, SinOsc.ar(440 + 200.rand, 0, 0.2)) }).send(s);<br>&nbsp;&nbsp;x = Synth("myDef");<br>&nbsp;&nbsp;y = Synth("myDef");<br>&nbsp;&nbsp;z = Synth("myDef");<br>&nbsp;&nbsp;x.free; y.free; z.free;</code></p><p><strong>Use arguments to create variety</strong><br>You could use the '<code>Rand</code>' <code>UGen</code> to <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/SynthDefs%20and%20Synths.html>get round this</a>, but more common to use <code>args</code>:</p><p class=code><code>&nbsp;&nbsp;SynthDef("myDef", { arg freq = 440, out = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Out.ar(out, SinOsc.ar(freq, 0, 0.2));<br>&nbsp;&nbsp;}).send(s);<br>&nbsp;&nbsp;x = Synth("myDef");<br>&nbsp;&nbsp;y = Synth("myDef", ["freq", 660]);<br>&nbsp;&nbsp;z = Synth("myDef", ["freq", 880, "out", 1]);</code></p><p><strong>Change values after instantiation</strong><br>Synth understands some methods which allow you to change the values of args after a synth has been created, one example is <code>set</code>:</p><p class=code><code>&nbsp;&nbsp;SynthDef.new("myDef", { arg freq = 440, out = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Out.ar(out, SinOsc.ar(freq, 0, 0.2));<br>&nbsp;&nbsp;}).send(s);<br>&nbsp;&nbsp;x = Synth.new("myDef");<br>&nbsp;&nbsp;x.set("freq", 660);<br>&nbsp;&nbsp;x.set("freq", 880, "out", 1);</code></p><p><strong>Use symbols not strings</strong><br><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Core/Symbol.html>Symbols</a> are more 'typesafe':</p><p class=code><code>&nbsp;&nbsp;"a String" === "a String";&nbsp;//false<br>&nbsp;&nbsp;\aSymbol === 'aSymbol';&nbsp;&nbsp;&nbsp;&nbsp;//true<br>&nbsp;&nbsp;"this" === \this;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//false</code></p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/First%20Steps.html class=linkheader name=Busses>Tutorial #10: Busses</a></span></strong></p><p><strong>Bus indices</strong><br>Busses are zero-indexed, in the order: out, in, private:</p><p class=code><code>&nbsp;&nbsp;2 outs, 2 ins&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4 outs, 2 ins<br>&nbsp;&nbsp;---------------------------------<br>&nbsp;&nbsp;0:&nbsp;Output 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0:&nbsp;Output 1<br>&nbsp;&nbsp;1:&nbsp;Output 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;Output 2<br>&nbsp;&nbsp;2:&nbsp;Input 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;Output 3<br>&nbsp;&nbsp;3:&nbsp;Input 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;Output 4<br>&nbsp;&nbsp;4:&nbsp;Private 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;Input 1<br>&nbsp;&nbsp;5:&nbsp;Private 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5:&nbsp;Input 2<br>&nbsp;&nbsp;etc.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6:&nbsp;Private 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7:&nbsp;Private 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;etc.</code></p><p>(See <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/ServerOptions.html>ServerOptions</a> for information on how to set the number of input and output channels, and busses)</p><p><strong>Read and write to bus indices</strong><br>Use bus indices directly (first arg is 'base' index, second argument is number of channels, counting up from that):</p><p class=code><code>&nbsp;&nbsp;Out.ar(0, SinOsc.ar(440, 0, 1));<br>&nbsp;&nbsp;In.ar(2, 1); //returns an OutputProxy<br>&nbsp;&nbsp;In.ar(2, 4); //returns an Array of 4 x OutputProxy</code></p><p><strong>Use Bus objects to avoid index-handling</strong><br>Get a two channel control <code>Bus</code>, and a one channel private audio <code>Bus</code> (one is the default):</p><p class=code><code>&nbsp;&nbsp;b = Bus.control(s, 2);<br>&nbsp;&nbsp;c = Bus.audio(s);</code></p><p><strong>Free up busses after use</strong><br>The indices from <code>Bus</code> can then be reallocated:</p><p class=code><code>&nbsp;&nbsp;b = Bus.control(s, 2);<br>&nbsp;&nbsp;b.free;</code></p><p><strong>Busses support downsampling but not upsampling</strong><br>The first is legal but the second is not:</p><p class=code><code>&nbsp;&nbsp;{Out.kr(0, SinOsc.ar)}.play;<br>&nbsp;&nbsp;{Out.ar(0, SinOsc.kr)}.play;</code></p><p>(However most <code>UGen</code>s support upsampling and some interpolate to create smooth waves)</p><p><strong>Multiple synths on the same bus are summed</strong><br>In other words, mixed:</p><p class=code><code>&nbsp;&nbsp;SynthDef("myDef", { arg freq = 440, out = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;Out.ar(out, SinOsc.ar(freq, 0, 0.2));<br>&nbsp;&nbsp;}).send(s);<br>&nbsp;&nbsp;// both write to bus 1, and their output is mixed<br>&nbsp;&nbsp;x = Synth("myDef", ["out", 1, "freq", 660]);<br>&nbsp;&nbsp;y = Synth("myDef", ["out", 1, "freq", 770]);</code></p><p><strong>Set the (constant) value of a kr bus</strong><br>Use <code>.set</code> to send a fixed value:</p><p class=code><code>&nbsp;&nbsp;b = Bus.control(s, 1); b.set(880);<br>&nbsp;&nbsp;c = Bus.control(s, 1); c.set(884);</code></p><p><strong>Get the value of a bus (delegate)</strong><br><code>.get</code> takes a delegate function as an argument, because of the latency involved in requesting the sample from the server. The interpreter will go ahead and execute the next line of the main thread:</p><p class=code><code>&nbsp;&nbsp;f = nil;<br>&nbsp;&nbsp;b = Bus.control(s, 1); b.set(880);<br>&nbsp;&nbsp;b.get({ arg val; val.postln; f = val; });<br>&nbsp;&nbsp;f.postln; //this will most likely be nil as it will be &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//executed before .get has had a response from &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//the server and executed the delegate</code></p><p><strong>Map a bus to a Synth argument</strong><br>Continuously evaluate a busses value in a Synth:</p><p class=code><code>&nbsp;&nbsp;b = Bus.control(s, 1); b.set(880);<br>&nbsp;&nbsp;c = Bus.control(s, 1); c.set(884);<br>&nbsp;&nbsp;x = SynthDef("myDef", { arg freq1 = 440, freq2 = 440;<br>&nbsp;&nbsp;&nbsp;&nbsp;Out.ar(0, SinOsc.ar([freq1, freq2], 0, 0.1));<br>&nbsp;&nbsp;}).play(s);<br>&nbsp;&nbsp;x.map(\freq1, b, \freq2, c);</code></p><p><strong>Order of execution</strong><br>Within each cycle, the server runs through all synths in order. You have to maintain a good order so that synths that write samples to a bus are calculated before the synths that read the samples from that bus:</p><p class=code><code>&nbsp;&nbsp;//.after and .before<br>&nbsp;&nbsp;x = Synth.new("xDef", [\bus, b]);<br>&nbsp;&nbsp;y = Synth.before(x, "yDef", [\bus, b]);<br>&nbsp;&nbsp;z = Synth.after(x, "zDef", [\bus, b]);<br><br>&nbsp;&nbsp;//equivalent to<br>&nbsp;&nbsp;x = Synth.new("xDef", [\bus, b]);<br>&nbsp;&nbsp;y = Synth.new("yDef", [\bus, b], x, \addBefore);<br>&nbsp;&nbsp;z = Synth.new("zDef", [\bus, b], x, \addAfter);</code></p><p>Above, <code>x</code> is the <code>target</code>, <code>[\addBefore, \addAfter, \attToHead, \addToTail, \addReplace]</code> is the <code>addAction</code>.</p><p>There are also methods: <code>[Synth.head, Synth.tail, Synth.replace]</code>.</p><p>See more on <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/Order-of-execution.html>Order of Execution</a>, including info on groups.</p><p><strong>Useful examples using busses</strong><br>There are some <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Busses.html>really useful example code listings</a> using busses - see <strong>Busses in Action</strong> and <strong>More Fun with Control Busses</strong>.</p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Groups.html class=linkheader name=Groups>Tutorial #11: Groups</a></span></strong></p><p><strong>Group and Synth both derive from Node</strong><br>A <code>Synth</code> and <code>Group</code> are both types of <code>Node</code>:</p><p class=code><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/\<br>&nbsp;&nbsp;&nbsp;&nbsp;Synth&nbsp;&nbsp;Group</code></p><p><strong>Groups for bulk ordering</strong><br><code>Group</code>s are useful for controlling order:</p><p class=code><code>&nbsp;&nbsp;~sources = Group.new;<br>&nbsp;&nbsp;~effects = Group.after(~sources); //whole ~effects group after<br><br>&nbsp;&nbsp;x = Synth(\anEffect, ~effects);<br>&nbsp;&nbsp;y = Synth(\aSource, ~sources);<br>&nbsp;&nbsp;z = Synth(\aSource, ~sources);</code></p><p>(<a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Groups.html>See an example</a> with actual <code>SynthDefs</code>)</p><p><strong>Groups for bulk messaging</strong><br><code>Group</code>s allow you to easily group together <code>Node</code>s and send them messages all at once:</p><p class=code><code>&nbsp;&nbsp;g = Group.new;<br>&nbsp;&nbsp;4.do({ { arg amp = 0.1; PinkNoise.ar(0.2); }.play(g); });<br>&nbsp;&nbsp;g.set(\amp, 0.005); // turn them all down<br></code></p><p><strong>Groups can contains Groups and Synths</strong><br>Each <code>Group</code> can contain a mixture of <code>Node</code>s, i.e. a combination of <code>Synth</code>s and more <code>Group</code>s, i.e:</p><p class=code><code>&nbsp;&nbsp;-Group<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Synth<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Synth<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Group<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Synth<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Synth<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Synth</code></p><p><strong>Query all nodes</strong><br>Find out what's happening on the server using <code>s.queryAllNodes</code>:</p><p class=code><code>&nbsp;&nbsp;nodes on localhost:<br>&nbsp;&nbsp;a Server<br>&nbsp;&nbsp;Group(0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//RootNode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group(1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//DefaultNode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group(1000)&nbsp;&nbsp;&nbsp;&nbsp;//User-defined Groups and Synths<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group(1001)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Synth 1002</code></p><p><strong>Root node and Default node</strong><br>- <code>RootNode</code> is a top-level for everything to hang off<br>- <code>DefaultNode</code> is where all your new nodes should go</p><p>It's so that methods such as <code>Server.scope</code> and <code>Server.record</code> (which create nodes which must come after everything else) can function without running into order of execution problems.</p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Buffers.html class=linkheader name=Buffers>Tutorial #12: Buffers</a></span></strong></p><p><strong>Arrays on the server</strong><br>Buffers are just in-memory arrays of floats on the server:</p><p class=code><code>&nbsp;&nbsp;[0.1, 0.2, 0.3, 0.4, 0.5] &nbsp;&nbsp;[0.5, 0.4, 0.3, 0.2, 0.1]</code></p><p>(They are designed to handle sound but could really be any values)</p><p><strong>Number of buffers available</strong><br>Like busses, the number of buffers is set before you boot a server (using <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/ServerOptions.html>ServerOptions</a>).</p><p><strong>Buffers are zero-indexed</strong><br>Buffers are zero-indexed, but as with Busses there is a handy <code>Buffer</code> class.</p><p><strong>Allocate a 2-channel buffer</strong><br>Use the <code>Buffer</code> class:</p><p class=code><code>&nbsp;&nbsp;s.boot;<br>&nbsp;&nbsp;b = Buffer.alloc(s, 100, 2); // 2 channels, 100 frames<br>&nbsp;&nbsp;b.free; // free the memory when done</code></p><p>(Actual number of values stored is numChannels * numFrames, in this case there will be 200 floats)</p><p><strong>Allocate in seconds rather than frames</strong><br>Multiply by the server's sample rate:</p><p class=code><code>&nbsp;&nbsp;b = Buffer.alloc(s, s.sampleRate * 8.0, 2); // 8 second stereo<br>&nbsp;&nbsp;b.free;</code></p><p><strong>Read a file into a buffer</strong><br>Read a file into a buffer:</p><p class=code><code>&nbsp;&nbsp;b = Buffer.read(s, "sounds/any.wav");</code></p><p><strong>Record sound into a buffer</strong><br>Record sound into a buffer:</p><p class=code><code>&nbsp;&nbsp;x = {RecordBuf.ar(PinkNoise.ar(0.3)!2, b)}.play;<br>&nbsp;&nbsp;x.free;</code></p><p><strong>Playback from a buffer</strong><br>Playback from a buffer:</p><p class=code><code>&nbsp;&nbsp;x = SynthDef("myDef",{ arg out = 0, buf;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Out.ar( out,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Args: numChannels, buffer, playbackSpeed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlayBuf.ar(1, buf, BufRateScale.kr(buf))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;}).play(s,[\buf, b]);</code></p><p>(<code>BufRateScale</code> scales the speed, in case the wavefile has a different sample rate to the server)</p><p><strong>Play a file straight off the disk</strong><br>Load it outside the synth so it can be reused. Note - no rate control:</p><p class=code><code>&nbsp;&nbsp;SynthDef("myDef",{ arg out=0, buf;<br>&nbsp;&nbsp;&nbsp;&nbsp;Out.ar(out,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DiskIn.ar( 1, buf )<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;}).send(s);<br><br>&nbsp;&nbsp;b = Buffer.cueSoundFile(s,"sounds/mySound.aiff", 0, 1);<br>&nbsp;&nbsp;y = Synth.new("myDef", [\buf,b], s);</code></p><p><strong>Get info from a buffer</strong><br>Use it's properties:</p><p class=code><code>&nbsp;&nbsp;b = Buffer.read(s, "sounds/mySound.wav");<br>&nbsp;&nbsp;b.bufnum;<br>&nbsp;&nbsp;b.numFrames;<br>&nbsp;&nbsp;b.numChannels;<br>&nbsp;&nbsp;b.sampleRate;<br>&nbsp;&nbsp;b.free;</code></p><p>...but make sure the file is loaded into the buffer first:</p><p class=code><code>&nbsp;&nbsp;b = Buffer.read(s, "sounds/mySound.wav", action: { arg buffer; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//read properties here &nbsp;&nbsp;});</code></p><p><strong>Get and set data values</strong><br>Remember multichannel buffers interleave their data, so for a two channel buffer index 0 = frame1-chan1, index 1 = frame1-chan2, index 2 = frame2-chan1, and so on:</p><p class=code><code>&nbsp;&nbsp;b = Buffer.alloc(s, 8, 1);<br>&nbsp;&nbsp;b.set(7, 0.5); //index, value<br>&nbsp;&nbsp;b.get(7, {|msg| msg.postln});</code></p><p><strong>Read / write multiple values</strong><br>Note the upper limit on the number of values you can get or set is usually 1633, due to packet size:</p><p class=code><code>&nbsp;&nbsp;b.setn(0, Array.fill(b.numFrames, {1.0.rand}));<br>&nbsp;&nbsp;b.getn(0, b.numFrames, {|msg| msg.postln});</code></p><p><strong>Read / write &gt; 1633 values</strong><br>Use <code>b.loadCollection</code> and <code>b.loadToFloatArray</code>:</p><p class=code><code>&nbsp;&nbsp;(<br>&nbsp;&nbsp;v = FloatArray.fill(44100, {1.0.rand2}); //white noise<br>&nbsp;&nbsp;b = Buffer.alloc(s, 44100);<br>&nbsp;&nbsp;)<br>&nbsp;&nbsp;(<br>&nbsp;&nbsp;// load the FloatArray into b, then play it<br>&nbsp;&nbsp;b.loadCollection(v, action: {|buf|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlayBuf.ar(buf.numChannels, buf, BufRateScale.kr(buf),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop: 1) * 0.2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.play;<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;)<br>&nbsp;&nbsp;x.free;<br><br>&nbsp;&nbsp;// Get the FloatArray back, compare it to v<br>&nbsp;&nbsp;// 0 = from beginning, -1 = load whole buffer<br>&nbsp;&nbsp;b.loadToFloatArray(0, -1, {|floatArray|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(floatArray == v).postln });<br>&nbsp;&nbsp;b.free;</code></p><p><strong>Plot and play</strong><br>Note <code>play</code>'s argument - loop. If false (default) the resulting synth is freed automatically:</p><p class=code><code>&nbsp;&nbsp;//see the waveform<br>&nbsp;&nbsp;b.plot;<br><br>&nbsp;&nbsp;//play the contents<br>&nbsp;&nbsp;b.play; //frees itself<br>&nbsp;&nbsp;x = b.play(true); //loops so doesn't free</code></p><p><strong>Buffers for waveshaping</strong><br>The method '<code>cheby</code>' fills the buffer with a series of chebyshev polynomials. The '<code>Shaper</code>' <code>UGen</code> then uses the dataset stored in the buffer to shape a <code>SinOsc</code>:</p><p class=code><code>&nbsp;&nbsp;b = Buffer.alloc(s, 512, 1);<br>&nbsp;&nbsp;b.cheby([1,0,1,1,0,1]);<br>&nbsp;&nbsp;x = play({<br>&nbsp;&nbsp;&nbsp;&nbsp;Shaper.ar(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SinOsc.ar(300, 0, Line.kr(0,1,6)),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5<br>&nbsp;&nbsp;&nbsp;&nbsp;)<br>&nbsp;&nbsp;});<br></code></p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Scheduling%20Events.html class=linkheader name=Scheduling-Events>Tutorial #13: Scheduling Events</a></span></strong></p><p><strong>Three types of clock</strong><br>Note that while there is only one <code>SystemClock</code>, there can be many <code>TempoClock</code>s all running at different speeds, if need be.</p><ul><li><code>TempoClock</code> - Musical sequencing, can change tempo and is aware of meter changes</li><li><code>SystemClock</code> - Actual time, in seconds</li><li><code>AppClock</code> - Also runs in seconds but has a lower system priority (better for graphic updates and other non-timecritical activities)</li></ul><p><strong>Schedule relative to current time</strong><br>Say 'hello' in 5 seconds:</p><p class=code><code>&nbsp;&nbsp;SystemClock.sched(5, { "hello".postln });</code></p><p><strong>Schedule for an absolute time</strong><br>Provide a time at which to say 'hello':</p><p class=code><code>&nbsp;&nbsp;var timeNow = TempoClock.default.beats;<br>&nbsp;&nbsp;TempoClock.default.schedAbs(timeNow + 5,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ "hello".post; nil });</code></p><p><strong>Change the tempo</strong><br>Change the tempo:</p><p class=code><code>&nbsp;&nbsp;TempoClock.default.tempo = 2; // 2 beats/sec, or 120 BPM</code></p><p><strong>Get a handle to the clock from inside a function</strong><br>Use <code>thisThread.clock</code>. Once you know the clock, you can find out what time it is using beats:</p><p class=code><code>&nbsp;&nbsp;SystemClock.beats;<br>&nbsp;&nbsp;TempoClock.default.beats;<br>&nbsp;&nbsp;AppClock.beats;<br>&nbsp;&nbsp;thisThread.clock.beats;</code></p><p><strong>Fire a function many times</strong><br>If you schedule a function that returns a number, the clock will treat that number as the amount of time before running the function again:</p><p class=code><code>&nbsp;&nbsp;TempoClock.default.sched(1, { rrand(1, 3).postln; });</code></p><p>(Stop it with <code>Cmd - .</code>)</p><p><strong>Fire a function once</strong><br>Return <code>Nil</code>:</p><p class=code><code>&nbsp;&nbsp;TempoClock.default.sched(1, { rrand(1, 3).postln; nil });</code></p><p><strong>Don't return zero</strong><br>You'll get an infinite loop.</p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Sequencing%20with%20Routines%20and%20Tasks.html class=linkheader name=Scheduling-with-Routines-and-Tasks>Tutorial #14: Scheduling with Routines and Tasks</a></span></strong></p><p>It's good to read about <code>Routine</code>s and <code>Task</code>s as taking this step-by-step approach to your understanding pay dividends when you learn <code>Pattern</code>s. However the examples given below can be more elegantly expressed - when you do this for real - using <code>Pattern</code>s. See Tutorial #15 for more when you are ready.</p><p>(See the <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Sequencing%20with%20Routines%20and%20Tasks.html>note on timing and latency</a> at the bottom if you do decide to go ahead with this approach, or read more about <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/ServerTiming.html>Server Timing</a>)</p><p><strong>Routines yield values</strong><br>The values are arbitrary. Execution is controlled by a pointer.</p><p>When <code>.next</code> is called on an instance of <code>Routine</code>, execution begins at the beginning of the specified function. When execution reaches a <code>.yield</code> command on a value, execution halts, the pointer is held in memory, and the value is returned.</p><p>When <code>.next</code> is called on the instance again, the pointer allows execution to continue from the current position, yielding the next yielded value, and so on.</p><p>When there are no more values available, the <code>Routine</code> instance will return <code>nil</code>.</p><p class=code><code>&nbsp;&nbsp;r = Routine({<br>&nbsp;&nbsp;&nbsp;&nbsp;"abcde".yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;"fghij".yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;"klmno".yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;"pqrst".yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;"uvwxy".yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;"z{|}~".yield;<br>&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;r.next;</code></p><p>Successive calls to <code>r.next</code> yield the following:</p><p class=code><code>&nbsp;&nbsp;abcde<br>&nbsp;&nbsp;fghij<br>&nbsp;&nbsp;klmno<br>&nbsp;&nbsp;pqrst<br>&nbsp;&nbsp;uvwxy<br>&nbsp;&nbsp;z{|}~<br>&nbsp;&nbsp;nil<br>&nbsp;&nbsp;nil</code></p><p><strong>You can schedule execution to begin again by yielding numeric values</strong><br>Instead of using <code>r.next</code>, use <code>TempoClock</code> as illustrated below, or the shorthand <code>r.play</code>. As before, execution picks up where it left off.</p><p class=code><code>&nbsp;&nbsp;r = Routine({<br>&nbsp;&nbsp;&nbsp;&nbsp;1.postln.yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;2.postln.yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;1.postln.yield;<br>&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;TempoClock.default.sched(0, r); //instead of r.next<br>&nbsp;&nbsp;r.play; //shorthand for the use of TempoClock<br></code></p><p>This code posts 1, then waits a second, posts 2, then waits two seconds, and finally posts 1 and waits one more second.</p><p><strong>Just keep yielding</strong><br>You can keep yielding and waiting indefinitely, using <code>loop</code>.</p><p class=code><code>&nbsp;&nbsp;r = Routine({<br>&nbsp;&nbsp;&nbsp;&nbsp;var delta;<br>&nbsp;&nbsp;&nbsp;&nbsp;loop {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta = rrand(1, 3) * 0.5;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Will wait ".post; delta.postln;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta.yield; //yield and return this value, which &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schedules the next execution.<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;TempoClock.default.sched(0, r);<br>&nbsp;&nbsp;r.play;</code></p><p><strong>Using .stop resets the pointer</strong><br>So that if you stop mid-way through a <code>Routine</code>, and then start again, the pointer will go back to the beginning of the function and the first value will be yielded again.</p><p class=code><code>&nbsp;&nbsp;r.play;<br>&nbsp;&nbsp;r.stop;</code></p><p><strong>Schedule a Task instead</strong><br>That's where <code>Task</code> steps in. <code>Task</code> is the same as <code>Routine</code>, except when you stop and restart a <code>Task</code>, the pointer position is retained and execution picks up again from there.</p><p class=code><code>&nbsp;&nbsp;t = Task({<br>&nbsp;&nbsp;&nbsp;&nbsp;loop {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[60, 62, 64, 65, 67, 69, 71, 72].do({ |midi|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Synth(\someSynth, [freq: midi.midicps]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.125.wait;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}).play;<br><br>&nbsp;&nbsp;t.stop; // probably stops in the middle of the scale<br>&nbsp;&nbsp;t.play; // should pick up with the next note</code></p><p><strong>Synchronise Tasks</strong><br><code>.play</code> takes several arguments to control its behavior:</p><p class=code><code>&nbsp;&nbsp;aRoutine.play(clock, quant)<br>&nbsp;&nbsp;aTask.play(clock, doReset, quant)</code></p><p>- <code>clock</code> (both): an instance of the clock you omitted by using the shorthand<br>- <code>doReset</code> (<code>Task</code> only): If true, reset the sequence to the beginning before playing; if false (default), resume<br>- <code>quant</code> (both): a quantizer. It's easier just to demonstrate:</p><p class=code><code>&nbsp;&nbsp;aTask.play(quant: 4); //start on next 4-beat boundary<br>&nbsp;&nbsp;aTask.play(quant: [4, 0.5]); //next 4-beat boundary + half-beat</code></p><p><strong>Use multiple datasets in a Task (with Routines)</strong><br>By splitting out data declaration from looping. Here using <code>Routine</code>s to store the datasets:</p><p class=code><code>&nbsp;&nbsp;//datasets<br>&nbsp;&nbsp;var midi = Routine({<br>&nbsp;&nbsp;&nbsp;&nbsp;[60, 72, 71, 67, 69, 71, 72, 60, 69, 67]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.do({ |midi| midi.yield });<br>&nbsp;&nbsp;});<br>&nbsp;&nbsp;var dur = Routine({<br>&nbsp;&nbsp;&nbsp;&nbsp;[2, 2, 1, 0.5, 0.5, 1, 1, 2, 2, 3]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.do({ |dur| dur.yield });<br>&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;//looping (in this case, once)<br>&nbsp;&nbsp;r = Task({<br>&nbsp;&nbsp;&nbsp;&nbsp;var delta;<br>&nbsp;&nbsp;&nbsp;&nbsp;while {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta = dur.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta.notNil<br>&nbsp;&nbsp;&nbsp;&nbsp;} {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Synth(\smooth, [freq: midi.next.midicps, sustain: delta]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta.yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}).play(quant: TempoClock.default.beats + 1.0);</code></p><p>(Note that the examples given here can be more elegantly expressed using <code>Pattern</code>s, see Tutorial #15)</p><p>(See the <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Sequencing%20with%20Routines%20and%20Tasks.html>note on timing and latency</a> at the bottom if you use this approach, or read more about <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/ServerTiming.html>Server Timing</a>)</p><p><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Sequencing%20with%20Patterns.html class=linkheader name=Scheduling-with-Patterns>Tutorial #15: Scheduling with Patterns</a></span></strong></p><p><strong>Use multiple datasets in a Task (with Patterns)</strong><br>Data declaration still split out from looping, but here using <code>Pattern</code>s to store the datasets:</p><p>(Note that the example given here can be more elegantly expressed using a <code>Pattern</code>-only approach, see below)</p><p class=code><code>&nbsp;&nbsp;//datasets<br>&nbsp;&nbsp;var midi = Pseq([60, 72, 71, 67, 69, 71, 72, 60, 69, 67], 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.asStream;<br>&nbsp;&nbsp;var dur = Pseq([2, 2, 1, 0.5, 0.5, 1, 1, 2, 2, 3], 1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.asStream;<br><br>&nbsp;&nbsp;//looping (in this case, once)<br>&nbsp;&nbsp;r = Task({<br>&nbsp;&nbsp;&nbsp;&nbsp;var delta;<br>&nbsp;&nbsp;&nbsp;&nbsp;while {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta = dur.next;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta.notNil<br>&nbsp;&nbsp;&nbsp;&nbsp;} {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Synth(\smooth, [freq: midi.next.midicps, sustain: delta]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delta.yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}).play(quant: TempoClock.default.beats + 1.0);</code></p><p>(<code>PSeq</code> means just spit out the values in declared order, as many times as the second argument - in this case, once)</p><p>(See the <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Sequencing%20with%20Routines%20and%20Tasks.html>note on timing and latency</a> at the bottom if you use this approach, or read more about <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/ServerArchitecture/ServerTiming.html>Server Timing</a>)</p><p><strong>Use multiple datasets (Patterns-only approach)</strong><br>Finally, <span style=text-decoration:underline>the most elegant</span> solution, using only <code>Pattern</code>s:</p><p class=code><code>&nbsp;&nbsp;(<br>&nbsp;&nbsp;SynthDef(\smooth, { |freq = 440, sustain = 1, amp = 0.5|<br>&nbsp;&nbsp;&nbsp;&nbsp;var sig;<br>&nbsp;&nbsp;&nbsp;&nbsp;sig = SinOsc.ar(freq, 0, amp) *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EnvGen.kr(Env.linen(0.05, sustain, 0.1), doneAction: 2);<br>&nbsp;&nbsp;&nbsp;&nbsp;Out.ar(0, sig ! 2)<br>&nbsp;&nbsp;}).add;<br>&nbsp;&nbsp;)<br><br>&nbsp;&nbsp;(<br>&nbsp;&nbsp;p = Pbind(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the name of the SynthDef to use for each note<br>&nbsp;&nbsp;&nbsp;&nbsp;\instrument, \smooth,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// MIDI note numbers -- converted automatically to Hz<br>&nbsp;&nbsp;&nbsp;&nbsp;\midinote, Pseq([60, 72, 71, 67, 69, 71, 72, 60, 69, 67], 1),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// rhythmic values<br>&nbsp;&nbsp;&nbsp;&nbsp;\dur, Pseq([2, 2, 1, 0.5, 0.5, 1, 1, 2, 2, 3], 1)<br>&nbsp;&nbsp;).play;<br>&nbsp;&nbsp;)</code></p><p>Here, <code>PBind</code> does the same job as the <code>Task</code> does in the previous codeblock. However, in a sense it uses <a href=http://en.wikipedia.org/wiki/Convention_over_configuration>convention over configuration</a> to give concise access to a common scenario. Only the necessary values are passed, using given argument names which correspond to the same actions as defined in the <code>Task</code> in the codeblock above.</p><p>(Note that the syntax is now right down to the bone - no programming constructs, almost just data. For completeness, this time I have included the example <code>SynthDef</code> (\smooth))</p><p><strong>Sample Pattern types: ordering</strong><br>Many patterns take lists of values and return them in some order:</p><p>Return the list's values in order:</p><p class=code><code>&nbsp;&nbsp;Pseq(list, repeats, offset)</code></p><p>Scramble the list into random order:</p><p class=code><code>&nbsp;&nbsp;Pshuf(list, repeats)</code></p><p>Choose from the list's values randomly:</p><p class=code><code>&nbsp;&nbsp;Prand(list, repeats)</code></p><p>Choose randomly, but never return the same list item twice in a row:</p><p class=code><code>&nbsp;&nbsp;Pxrand(list, repeats)</code></p><p>Like Prand, but chooses values according to a list of probabilities/weights:</p><p class=code><code>&nbsp;&nbsp;Pwrand(list, weights, repeats)</code></p><p><strong>Sample Pattern types: generate based on parameters</strong><br>In addition to these basic patterns, there is a whole set of random number generators that produce specific distributions, and also chaotic functions:</p><p>Arithmetic series, e.g., 1, 2, 3, 4, 5:</p><p class=code><code>&nbsp;&nbsp;Pseries(start, step, length)</code></p><p>Geometric series, e.g., 1, 2, 4, 8, 16:</p><p class=code><code>&nbsp;&nbsp;Pgeom(start, grow, length)</code></p><p>Random number generator, uses <code>rrand(lo, hi)</code> -- equal distribution:</p><p class=code><code>&nbsp;&nbsp;Pwhite(lo, hi, length)</code></p><p>Random number generator, uses <code>exprand(lo, hi)</code> -- exponential distribution:</p><p class=code><code>&nbsp;&nbsp;Pwhite(lo, hi, length)</code></p><p><strong>Sample Pattern types: modify the output of other Patterns</strong><br>Other patterns modify the output of value patterns. These are called <code>FilterPatterns</code>:</p><p>Repeat the pattern as many times as repeats indicates:</p><p class=code><code>&nbsp;&nbsp;Pn(pattern, repeats)</code></p><p>Repeat individual values from a pattern n times. n may be a numeric pattern itself:</p><p class=code><code>&nbsp;&nbsp;Pstutter(n, pattern)</code></p><p><strong>Sample Pattern types: Patterns inside other Patterns</strong><br>Other patterns modify the output of value patterns. These are called <code>FilterPatterns</code>:</p><p>Random numbers over a gradually increasing range (the upper bound on the random number generator is a stream that starts at 0.01, then proceeds to 0.02, 0.03 and so on, as the plot shows clearly):</p><p class=code><code>&nbsp;&nbsp;p = Pwhite(0.0, Pseries(0.01, 0.01, inf), 100).asStream;<br>&nbsp;&nbsp;&nbsp;&nbsp;// .all pulls from the stream until it returns nil<br>&nbsp;&nbsp;&nbsp;&nbsp;// obviously you don't want to do this for an 'inf'<br>&nbsp;&nbsp;&nbsp;&nbsp;// length stream!<br>&nbsp;&nbsp;p.all.plot;</code></p><p>Order a set of numbers randomly so that all numbers come out before a new order is chosen, use <code>Pn</code> to repeat a <code>Pshuf</code>:</p><p class=code><code>&nbsp;&nbsp;p = Pn(Pshuf([1, 2, 3, 4, 5], 1), inf).asStream;<br>&nbsp;&nbsp;p.nextN(15); // get 15 values from the pattern's stream</code></p><p><strong>Patterns: further reading</strong><br>This is just an intro - see more documentation to really understand it:</p><ul><li><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Streams-Patterns-Events/Streams.html>Streams / Patterns / Events - helpfile</a></li><li><a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Streams-Patterns-Events/A%20Practical%20Guide/PG_01_Introduction.html>A Practical Guide to Patterns</a></li></ul><br><p>End of tutorial!</p><hr><p id=Quick-references><span style=float:right class=backtotop>[<a href=#top>back to top</a>]</span><strong><span style=text-decoration:underline class=linkheader>Quick references</span></strong><br>Here is a quick summary of methods and keyboard shortcuts found in the tutorial, plus a couple of helpful extras:</p><p><strong><span style=text-decoration:underline id=Commonly-used-methods>Commonly-used methods</span></strong></p><table class=displaytable><tr><td style="width: 120px"><code>.new</code></td><td>Create new object(s) from a static method.<br>Note that e.g. <code>Mix.new(x)</code> is equiv to <code>Mix(x)</code></td></tr><tr><td style="width: 120px"><code>.post</code></td><td>Post the object to the console as a string</td></tr><tr><td><code>.postln</code></td><td>As above with newline</td></tr><tr><td><code>.value</code></td><td>Return the object's value<br>(evaluate if it's a function, or just return the object itself)</td></tr><tr><td><code>.play</code></td><td>To functions, 'play' means evaluate yourself and play the result on a server</td></tr><tr><td><code>.choose</code></td><td>To arrays, means pick any element. The element could be another array (i.e. stereo) or a single value. Arrays can be <a href=http://supercollider.svn.sourceforge.net/viewvc/supercollider/trunk/common/build/Help/Tutorials/Getting-Started/Presented%20in%20Living%20Stereo.html>mixed</a> i.e.<br><code>[[126,213],[415,314],231,344]</code></td></tr><tr><td><code>!2</code></td><td>Quickly make mono into stereo</td></tr></table><p><strong><span style=text-decoration:underline id=Commonly-used-keyboard-shortcuts>Commonly-used keyboard shortcuts</span></strong></p><table class=displaytable><tr><td style="width: 120px"><code>Cmd - \</code></td><td>Bring the console window to the front</td></tr><tr><td><code>Cmd-SHIFT-C</code></td><td>Clear the console</td></tr><tr><td><code>Cmd - .</code></td><td>Stop all playback</td></tr><tr><td><code>Cmd - D</code></td><td>Open the helpfile for whatever is currently selected</td></tr><tr><td><code>Cmd - J</code></td><td>Open the definition file for whatever is currently selected</td></tr><tr><td><code>Cmd - Y</code></td><td>(On a method) Show a list of classes which implement this method (polymorphism)</td></tr></table><p><strong><span style=text-decoration:underline id=Special-arguments>Special arguments</span></strong></p><table class=displaytable style=width:100%><tr><td style="width: 120px"><code>index</code></td><td>Injects the current iterator into a loop, e.g.<br><code>(<br>&nbsp;3.do({<br>&nbsp;&nbsp;|index|<br>&nbsp;&nbsp;index.postln;<br>&nbsp;});<br>)<br>//Prints 1 2 3</code></td></tr><tr><td style="width: 120px"><code>midinote</code> / <code>freq</code></td><td>The argument <code>midinote</code> gets converted into a frequency value, and passed as the argument <code>freq</code>, e.g.<br><code>(<br>&nbsp;SynthDef(\myInst, { |freq|<br>&nbsp;&nbsp;Out.ar(0,<br>&nbsp;&nbsp;&nbsp;SinOsc.ar(freq) *<br>&nbsp;&nbsp;&nbsp;EnvGen.kr(<br>&nbsp;&nbsp;&nbsp;&nbsp;Env.linen(0.1, 0.8, 0.1), doneAction: 2)<br>&nbsp;&nbsp;! 2)<br>&nbsp;}).add;<br><br>&nbsp;p = Pbind(<br>&nbsp;&nbsp;\instrument, \myInst,<br>&nbsp;&nbsp;\midinote, Pseq([60, 72], inf)<br>&nbsp;).play;<br>)<br></code><br>See also <a href=#Scheduling-with-Patterns>Tutorial #15: Scheduling with Patterns</a></td></tr><tr><td style="width: 120px"><code>dur</code></td><td>Duration - see <a href=#Scheduling-with-Patterns>Tutorial #15: Scheduling with Patterns</a></td></tr><tr><td style="width: 120px"><code>instrument</code></td><td>See <a href=#Scheduling-with-Patterns>Tutorial #15: Scheduling with Patterns</a></td></tr></table></div></article><ul id=paging class=cta><li><a href=/blog/getting-started-with-supercollider>&lt; Previous post</a></li><li><a href=/blog/switching-to-macbook-pro>Next post &gt;</a></li></ul></main><aside class=right><nav><header><h1>All posts</h1></header><h2 id=2015-ref>2015</h2><ul><li><a href=/blog/new-site-for-hardware-hack-lab>New Site for Hardware Hack Lab</a></li></ul><h2 id=2014-ref>2014</h2><ul><li><a href=/blog/sound-control-at-future-interfaces>Sound Control at Future Interfaces</a></li><li><a href=/blog/projection-masking-not-projection>Projection Masking, not Projection Mapping</a></li><li><a href=/blog/addon-for-openframeworks-kinect-v2-and>Addon for openFrameworks, Kinect V2 and Mac</a></li><li><a href=/blog/john-cleese-on-creativity>John Cleese on Creativity</a></li><li><a href=/blog/takeaways-from-eyeo-2014>Takeaways from Eyeo 2014</a></li><li><a href=/blog/hardware-hacker-culture-of-new-york>Hardware Hacker Culture of New York</a></li><li><a href=/blog/future-visions-for-human-interaction>Future Visions for Human Interaction</a></li><li><a href=/blog/openbci-nears-its-kickstarter-goal>OpenBCI Nears it's Kickstarter Goal</a></li></ul><h2 id=2013-ref>2013</h2><ul><li><a href=/blog/sound-chamber-2013>Sound Chamber (2013)</a></li><li><a href=/blog/openbci-hackathon-at-thoughtworks>OpenBCI Hackathon at ThoughtWorks</a></li><li><a href=/blog/exploring-depth-video-at-culturehub>Exploring Depth Video at CultureHub</a></li><li><a href=/blog/introduction-to-ibeacons>Introduction to iBeacons</a></li><li><a href=/blog/volumetric-lab-at-culturehub-nyc>Volumetric Lab at CultureHub NYC</a></li><li><a href=/blog/randomness-in-algorithm>Randomness in the Algorithm</a></li><li><a href=/blog/study-existential>Video: Existential</a></li><li><a href=/blog/the-visual-art-of-brian-eno>The Visual Art of Brian Eno</a></li><li><a href=/blog/rgbdtoolkit-sketch-at-sampler>RGBDToolkit Sketch at The Sampler</a></li><li><a href=/blog/the-artist-geek-hybrid>The Artist-Geek Hybrid</a></li><li><a href=/blog/rgbdtoolkit-calibration-tutorial>RGBDToolkit Calibration Tutorial</a></li><li><a href=/blog/how-depth-sensor-works-in-5-minutes>How a Depth Sensor Works - in 5 Minutes</a></li><li><a href=/blog/focal-lengths-and-camera-sensors>Focal Lengths and Camera Sensors</a></li><li><a href=/blog/rgbdtoolkit-visualizer-tutorial>RGBDToolkit Visualizer Tutorial</a></li><li><a href=/blog/rgbdtoolkit-workshop-at-eyebeam>RGBDToolkit Workshop at Eyebeam</a></li><li><a href=/blog/nosql-distilled-to-keynote>NoSQL Distilled to a Keynote!</a></li><li><a href=/blog/paper-prototyping>Paper Prototyping</a></li><li><a href=/blog/git-vs-github>Is Git the Same Thing as Github!?</a></li></ul><h2 id=2012-ref>2012</h2><ul><li><a href=/blog/counterpoint-to-remote>Counterpoint to the Remote</a></li><li><a href=/blog/the-cascading-process>The Cascading Process</a></li><li><a href=/blog/working-with-total-space>Working with Total Space</a></li><li><a href=/blog/residency-begins-at-cac-troy>Residency Begins at CAC Troy</a></li><li><a href=/blog/installation-sketch-at-open-studios>Installation Sketch at Open Studios</a></li><li><a href=/blog/roman-moshenskys-mirror-world>Roman Moshensky's Mirror World</a></li><li><a href=/blog/open-studios-at-i-park>Open Studios at I-Park</a></li><li><a href=/blog/perception-as-creative-process>Perception as a Creative Process</a></li><li><a href=/blog/the-i-park-graveyard>The I-Park Graveyard</a></li><li><a href=/blog/scoping-out-land>Scoping Out the Land</a></li><li><a href=/blog/residency-begins-at-i-park>Residency Begins at I-Park</a></li><li><a href=/blog/residency-at-contemporary-artists-center>Residency at Contemporary Artists Center</a></li><li><a href=/blog/the-shopping-list-for-projection-bombing>First Shopping List for Projection-Bombing</a></li><li><a href=/blog/portable-projection-in-rural-context>Portable Projection in a Rural Context</a></li><li><a href=/blog/stephen-lumentas-sc-textmate-bundle>Stephen Lumenta's SC TextMate Bundle</a></li><li><a href=/blog/adding-openframeworks-addons>Adding OF Addons (ofxSuperCollider)</a></li><li><a href=/blog/setting-up-supercollider-with-textmate>Setting up SuperCollider with TextMate</a></li><li><a href=/blog/switching-to-macbook-pro>Switching to MacBook Pro</a></li><li><a href=/blog/quickref-for-supercollider>QuickRef for SuperCollider</a></li><li><a href=/blog/getting-started-with-supercollider>Getting Started with SuperCollider</a></li><li><a href=/blog/getting-started-with-openframeworks-in>Getting Started with OpenFrameworks</a></li><li><a href=/blog/overtones-harmonics-and-additive>Overtones, Harmonics and Additive Synthesis</a></li><li><a href=/blog/visit-to-cold-spring>Visit to Cold Spring</a></li><li><a href=/blog/i-park-residency>Residency at I-Park</a></li><li><a href=/blog/light-waves>Light Waves</a></li></ul><h2 id=2011-ref>2011</h2><ul><li><a href=/blog/final-exhibition>The Final Exhibition</a></li><li><a href=/blog/playing-with-particles>Playing with Particles</a></li><li><a href=/blog/responsive-granular-sound>Responsive Granular Sound</a></li><li><a href=/blog/kinecting-to-network>Kinecting to the Network</a></li><li><a href=/blog/first-working-day>First Working Day</a></li><li><a href=/blog/designs-for-freemote>Designs for Freemote</a></li><li><a href=/blog/freemote-utrecht>Freemote Utrecht</a></li><li><a href=/blog/untitled-picture-this-2011>Untitled - Picture This (2011)</a></li><li><a href=/blog/wider-context>The Wider Context?</a></li><li><a href=/blog/trading-time-for-space>Trading Time for Space</a></li><li><a href=/blog/talk-at-goldsmiths-digital-studios>Talk at Goldsmiths Digital Studios</a></li><li><a href=/blog/intro-to-marius-watz>Intro to Marius Watz</a></li><li><a href=/blog/practical-guide-to-generative-art>Practical Guide to Generative Art</a></li><li><a href=/blog/installation-at-alpha-ville>Installation at Alpha-Ville</a></li><li><a href=/blog/simple-harmonic-motion>Simple Harmonic Motion</a></li><li><a href=/blog/jaaga-journal-features>Jaaga Journal Features</a></li><li><a href=/blog/gravity-2011>Gravity (2011)</a></li><li><a href=/blog/reflections-2011>Reflections (2011)</a></li><li><a href=/blog/jaaga-sound-lights>Jaaga Sound & Lights</a></li><li><a href=/blog/two-works-for-jaaga-gravity-and-memory>Two Works for Jaaga: Gravity and Reflections</a></li><li><a href=/blog/cosm-collision-detection-and-volume>Cosm, Collision Detection and Volume</a></li><li><a href=/blog/vector-base-amplitude-panning>Vector-Base Amplitude Panning</a></li><li><a href=/blog/intuition-and-direction-of-project>Intuition, and Direction of the Project</a></li><li><a href=/blog/reflections-what-is-jaaga>Reflections: What is Jaaga?</a></li><li><a href=/blog/going-further-with-ambisonics>Going Further with Ambisonics</a></li><li><a href=/blog/introduction-to-ambisonics>Introduction to Ambisonics</a></li><li><a href=/blog/surface-light-sound-installation>Surface (2010)</a></li><li><a href=/blog/running-servo-motor>Servo Motors and Transistors</a></li><li><a href=/blog/spinning-12v-dc-motor>Spinning a 12V DC Motor</a></li><li><a href=/blog/spinning-dc-motor>Spinning a 5V DC Motor</a></li><li><a href=/blog/first-week-at-jaaga>First Week at Jaaga</a></li><li><a href=/blog/presentation-style>Presentation Style</a></li><li><a href=/blog/beginning-jaaga-fellowship>Beginning the Jaaga Fellowship</a></li><li><a href=/blog/brian-eno-role-models-and-direction>Brian Eno, Role Models and Direction</a></li><li><a href=/blog/hype-cycle_17>The Hype Cycle</a></li></ul><h2 id=2010-ref>2010</h2><ul><li><a href=/blog/working-with-3d-space>Working with 3D Space</a></li><li><a href=/blog/technology-and-luck>Technology and Luck</a></li><li><a href=/blog/gallery-types-and-commercial-gallery>Different Types of Gallery</a></li><li><a href=/blog/jason-bruges-studio>Jason Bruges Studio</a></li><li><a href=/blog/unstable-empathy-trust-and>Unstable Empathy & Gaining Trust</a></li><li><a href=/blog/chris-o-two-creative-cultures>Chris O'Shea & Two Creative Cultures</a></li></ul></nav></aside></div><script src=/javascript/script.e2be.js></script></body></html>